---
title: "Selection of locations for insect monitoring in oaks"
author: "Jens Å"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  NinaR::jensAnalysis:
    highlight: tango
    fig_caption: yes
    toc: yes
---


```{r, include = F}
# Some common packages, loading rmarkdown doesn't like the messages from tidyverse, so we don't include this in the document'
require(tidyverse)
require(DBI)
require(RPostgres)
require(ggplot2)
require(xtable)
require(NinaR)
require(openxlsx)
require(tmap)
require(sf)
require(Norimon)
```



```{r setup, include=FALSE}
# This is optional
# I choose the 'styler' package for tidying the code to preserve indentations
# I set the cutoff for code tidying to 60, but this doesn't currently work with styler.
# Set tidy = True to get the knitr default
# I want all figures as png and pdf in high quality in a subfolder called figure

knitr::opts_chunk$set(
  echo = TRUE,
  tidy = "styler",
  dev = c("png", "pdf"),
  dpi = 600,
  fig.path = "figure/"
)

options(
  xtable.comment = F,
  xtable.include.rownames = F,
  nina.logo.y.pos = 0.15
)
palette(ninaPalette())
```

Set up a cache variable for saving intermediate work. Set it to false to use stored intermediates. Set to TRUE to rerun from scratch.
```{r}
cache_var = FALSE
```


```{r}
con <- NinaR::postgreSQLConnect()
```



## Plan
### From Rannveig's notes.

Vi skal trekke 150 eiker (100 til overvåkingen, men må ha ekstra for å justere i forhold til logistikk, grunneiertillatelse og i felt feks om noen trær er borte) fra de 600 ARKO-eikene (657 minus «gone» og «not found» i 2019), etter følgende kriterier: 

Doblet sannsynlighet for å trekke trær med omkrets over 200 cm. 

Andel eiker i vårt utvalg speiler fordelingen blant alle ARKO-eiker; hvis det feks er 20% i Vestland, 30% i Agder, 30% i V/T, 20% i Viken, så skal overvåkingseikene fordeles etter samme andeler. 

Maks 2 overvåkingstrær per ARKO-rute. 

Da hule eiker i utgangspunktet er relativt jevnt fordelt mellom skog og åpent landskap, regner vi med at dette vil reflekteres i utvalget av overvåkingstrær uten å legge inn noe styrende kriterium for dette. Vi sjekker om vi har tilfredsstillende fordeling av eiker i skog og utenfor skog totalt og i hver region etter å ha trukket et sett overvåkingstrær. 

Etter å ha gjort et utvalg sjekker vi fordeling i forhold til ulike parametre (feks hulrom, vedmuld, barktype, treform), særlig hvor mange A-eiker som er representert.  

In addition to this, we only will consider squares with a single tree if that square isn't too far away from other squares (other chosen squares?)


### Jens interpretation
It's not that straightforward to meet all these criteria, with an 'automatic' algorithm. Need to set up a random draw with a set total size, that is weighted on tree diameter, allows up to 2 trees per square, only takes squares if they are closer to other squares than a set distance.

Apropos "double probability to draw a tree > 200 cm in circumference". This can be interpreted in several ways. There are slightly more trees above the treshold, so a random sample will produce a higher probability of large trees anyway. We could interpret it as drawing double the amount of large trees (>200cm) than smalller.




After some thinking, I will try this algorithm, based on a random draw of trees, with later filtering:

1. Order the trees randomly. I.e., draw a random order of all trees, with probablities based on tree diameter.
2. Note the distance for each square to the closest square.
3. Note the (randomly drawn) order of trees within each square.
4. Note the randomly drawn order of squares.
5. Record the total number of trees within each square.
6. Discard trees with order > 2.
7. Discard squares with total number of trees <2 & distance_to_nearest_neighbor < distance_limit (Note that actually should depend on that the other squares are selected the same year. This get's complex.)



## Load the source excel-file

```{r}

loc_raw <- openxlsx::read.xlsx("../rawData/Oak_2017data_2019resurveydata.xlsx") %>% 
  as_tibble

loc_raw
```
Filter out trees that is gone or not found in 2019.

```{r}
loc <- loc_raw %>% 
  filter(Gone != 1,
         Not_found != 1) 

nrow(loc)
```
```{r}
loc %>% 
  group_by(Omkrets > 200) %>% 
  summarise(no = n())
```

A quick look at the distribution of trees
----------

```{r}
no_rute <- loc %>% 
  summarise(no_rute = n_distinct(RuteID)) %>% 
  pull

squares <- loc %>% 
  select(RuteID) %>% 
  distinct() %>% 
  pull()
```

```{r}
loc_with_at_least_two <- loc %>% 
  group_by(RuteID) %>% 
  summarise(no_trees = n()) %>% 
  filter(no_trees > 1) %>% 
  summarise(n_distinct(RuteID)) %>% 
  pull()
  
```

We have `r no_rute` distinct survey squares (SSB) to choose from. But only `r loc_with_at_least_two` survey squares with at least 2 trees (if we want to restrict it to that).


```{r tree_square_dist}
loc %>% 
  group_by(RuteID) %>% 
  summarise(no_trees = n()) %>% 
  ggplot() +
  geom_bar(aes(x = no_trees)) +
  geom_vline(aes(xintercept = 2),
             col = "red") +
  xlab('Antall trær innen én rute') +
  ylab('Antall ruter')
```

Add info on distance to other squares
---------

Add a column with distances to the other squares (if we want to use squares with only 1 tree, if they are close enough to other squares)

Make an SF object (create a geometry).

```{r}

loc_sf <- loc %>% 
  st_as_sf(coords = c("UTM32_X_koordinat",
                      "UTM32_Y_koordinat"),
           crs = 25832)

```

Get the ssb square geometries (from the gisdata database).

```{r get_ssb_500m, eval = cache_var}
ssb_500m <- read_sf(con,
                Id(schema = "ssb_data_utm33n",
                   table = "ssb_500m")) %>% 
  st_transform(crs = 25832)

cand_ssb_500m <- ssb_500m %>% 
 st_join(loc_sf, 
         left = FALSE) %>% 
  mutate(ssbid = as.character(ssbid)) %>% 
  select(ssbid) %>% 
  distinct()

system("mkdir -p out")

save(cand_ssb_500m,
     file = "out/cand_ssb_500m.Rdata")

```

```{r, eval = !cache_var}
load(file = "out/cand_ssb_500m.Rdata")
```


Get the distance to the nearest neighbor ssb square.

```{r}
cand_ssb_500m <- cand_ssb_500m  %>% 
  mutate(nearest_dist = st_distance(., cand_ssb_500m[st_nearest_feature(cand_ssb_500m), ], by_element = TRUE))

cand_ssb_500m %>% 
  select(ssbid, nearest_dist) %>% 
  arrange(nearest_dist)
```

Get some background geometries.

```{r}
regions <- read_sf(con,
               Id(schema = "insect_survey",
                  table = "new_landsdel"))

south <- regions %>% 
  filter(!(fylke %in% c("Trøndelag", "Nordland", "Troms og Finnmark")))
```


```{r, eval = F, echo = F}
tmap_mode("view")
tm_shape(south) +
  tm_borders() +
tm_shape(cand_ssb_500m) +
  tm_polygons() 
```

Join the locations with the ssbids and distances.

```{r}
loc_sf <- loc_sf %>% 
 st_join(cand_ssb_500m, 
         left = TRUE)
```
```{r, eval = F}
loc_sf %>% 
  select(ssbid, nearest_dist)
```

Add large/small tree category.

```{r}
loc_sf <- loc_sf %>% 
  mutate(large = Omkrets > 200)
```


```{r all_trees}
#tmap_mode("view")
tm_shape(south) +
  tm_borders() +
tm_shape(cand_ssb_500m) +
  tm_borders() +
  tm_shape(loc_sf) +
  tm_dots(col = "large",
             size = 0.1,
          palette = ninaPalette())
```

Draw random selection of trees
-------------

```{r}
largest_dist_to_neighbor_m = 30000 #as the bird flies (might be longer on roads)
```

Draw random order.

```{r}
set.seed(12345)

tree_sel_random_order <- loc_sf %>% 
  filter(!is.na(large)) %>% #Must know the diameter
  mutate(sel_prob = ifelse(large, 2/3, 1/3)) %>%  #double the probability for large trees 
  slice(sample(1:n(), n(), prob = sel_prob)) %>% 
  ungroup() %>% 
  mutate(rand_selection_order = row_number())

```
Note tree order within squares, total amount of trees within square, and (random) rute order. Order it after square random order and tree random order within squares.

```{r}
#This was surprisingly tricky. Needed to make a character factor to be able to preserve the order of appearence with fct_inorder

tree_sel_random_order <- tree_sel_random_order %>% 
  group_by(RuteID) %>% 
  mutate(tree_order_within_square = row_number(),
         no_trees_within_square = n()) %>% 
  ungroup() %>% 
  mutate(rute_id_rand_order = forcats::fct_inorder(paste0("rute_", RuteID))) %>% 
  group_by(rute_id_rand_order) %>% 
  mutate(rute_id_order = cur_group_id())  %>% 
  arrange(rute_id_order,
          tree_order_within_square) %>% 
  ungroup() %>%
  mutate(selection_order = row_number())


```

```{r, eval = F}
tree_sel_random_order %>% 
  st_drop_geometry() %>% 
 select(RuteID, 
         rute_id_rand_order,
         rute_id_order,
         tree_order_within_square,
         no_trees_within_square) 
#%>% 
 # print(n = 80)
```

Add a note if single trees are farther away than distance limit. 
```{r}
tree_sel_random_order <- tree_sel_random_order %>% 
  mutate(single_and_lonely = no_trees_within_square < 2 & 
           nearest_dist < units::set_units(largest_dist_to_neighbor_m, "m"),
         fylke_navn = "",
         kommune_navn = "",
         kommune_no_2022 = "") %>% 
  select(selection_order,
         rand_selection_order,
         rute_id_order,
         tree_order_within_square,
         single_and_lonely,
         no_trees_within_square,
         RuteID,
         everything()
         )
```
This gives us 30 single trees farther away than `r largest_dist_to_neighbor_m` meters to other surveyed squares.

```{r}
tree_sel_random_order %>% 
  filter(single_and_lonely) %>% 
  select(RuteID, 
         rute_id_rand_order,
         rute_id_order,
         tree_order_within_square,
         no_trees_within_square) 
```


Save this complete list for QGIS. Also do some PostGIS stuff.

```{r, eval = cache_var}
#Need my permissions
my_con <- dbConnect(Postgres(),
                    host = "gisdata-db.nina.no",
                    dbname = "gisdata")

dbWriteTable(my_con,
             name = Id(schema = "hule_eiker_insekt",
                       table = "oak_sel_random_order"),
             value = tree_sel_random_order,
         overwrite = TRUE)

dbSendStatement(my_con,
                "
                ALTER TABLE hule_eiker_insekt.oak_sel_random_order 
                ADD PRIMARY KEY(row_number);
                ")

dbSendStatement(my_con,
                "
  ALTER TABLE hule_eiker_insekt.oak_sel_random_order 
  ADD COLUMN geom Geometry(Point, 25832);
  ")

dbSendStatement(my_con,
                "
  ALTER TABLE hule_eiker_insekt.oak_sel_random_order 
  ADD COLUMN geom_25833 Geometry(Point, 25833);
  
  ")

dbSendStatement(my_con,
                "
                UPDATE hule_eiker_insekt.oak_sel_random_order
                set geom = geometry::Geometry(Point, 25832),
                geom_25833 = ST_Transform(geometry, 25833)::Geometry(Point, 25833)
                ")

dbSendStatement(my_con,
                "
  ALTER TABLE hule_eiker_insekt.oak_sel_random_order 
  DROP COLUMN geometry;
  ")

dbSendStatement(my_con,
                "
                CREATE INDEX ON hule_eiker_insekt.oak_sel_random_order USING Gist(geom);
                ")

dbSendStatement(my_con,
                "
                CREATE INDEX ON hule_eiker_insekt.oak_sel_random_order USING Gist(geom_25833);
                ")
dbSendStatement(my_con,
                "
UPDATE hule_eiker_insekt.oak_sel_random_order oak
set fylke_navn = f.navn
FROM \"AdministrativeUnits\".norway_counties_fylker_polygons_2020 f
WHERE ST_Intersects(oak.geom_25833, f.geom)
                ")

dbSendStatement(my_con,
                "
UPDATE hule_eiker_insekt.oak_sel_random_order oak
set kommune_navn = f.navn
FROM \"AdministrativeUnits\".norway_municipalities_kommuner_polygon_2020 f
WHERE ST_Intersects(oak.geom_25833, f.geom)
                ")

dbSendStatement(my_con,
                "
UPDATE hule_eiker_insekt.oak_sel_random_order oak
set kommune_no_2022 = f.kommunenum
FROM \"AdministrativeUnits\".norway_municipalities_kommuner_polygon_2020 f
WHERE ST_Intersects(oak.geom_25833, f.geom)
                ")


dbSendStatement(my_con,
                "
  ALTER TABLE hule_eiker_insekt.oak_sel_random_order ADD COLUMN east_west text;
  ")

dbSendStatement(my_con,
                "
UPDATE hule_eiker_insekt.oak_sel_random_order oak
set east_west = CASE 
WHEN fylke_navn IN ('Oslo', 'Vestfold og Telemark','Viken') 
THEN 'east' 
ELSE 'west'
END;

")


dbSendStatement(my_con,
                "
  ALTER TABLE hule_eiker_insekt.oak_sel_random_order ADD COLUMN lon_lat_25833 text;
  ")

dbSendStatement(my_con,
                "
                UPDATE hule_eiker_insekt.oak_sel_random_order
                SET lon_lat_25833 = round(ST_X(geom_25833)::numeric, 6) || 
                  ',' || round(ST_Y(geom_25833)::numeric, 6)
                ")


dbSendStatement(my_con,
                "
  ALTER TABLE hule_eiker_insekt.oak_sel_random_order 
  ADD COLUMN matrikkel_no text;
  ")


dbSendStatement(my_con,
                "
  ALTER TABLE hule_eiker_insekt.oak_sel_random_order 
  ADD COLUMN grunneier text;
  ")


dbSendStatement(my_con,
                "
  ALTER TABLE hule_eiker_insekt.oak_sel_random_order 
  ADD COLUMN grunneier_telefon text;
  ")

dbSendStatement(my_con,
                "
  ALTER TABLE hule_eiker_insekt.oak_sel_random_order 
  ADD COLUMN grunneier_epost text;
  ")

dbSendStatement(my_con,
                "
  ALTER TABLE hule_eiker_insekt.oak_sel_random_order
  ADD COLUMN grunneier_adresse text;
  ")

dbSendStatement(my_con,
                "
  ALTER TABLE hule_eiker_insekt.oak_sel_random_order
  ADD COLUMN kommentar text;
  ")


dbSendStatement(my_con,
                "
  GRANT ALL ON TABLE hule_eiker_insekt.oak_sel_random_order TO \"oyvind.hamre\"
                "
                )

dbSendStatement(my_con,
                "
  GRANT ALL ON TABLE hule_eiker_insekt.oak_sel_random_order TO \"rannveig.jacobsen\"
                "
                )

dbSendStatement(my_con,
                "
  GRANT ALL ON TABLE hule_eiker_insekt.oak_sel_random_order TO gisuser;
                "
                )

 dbSendStatement(my_con,
                 "
   UPDATE hule_eiker_insekt.oak_sel_random_order o
   SET matrikkel_no =  teig.kommunenummer || ';' ||
    REPLACE(teig.matrikkelnummertekst, '/', ';')

   FROM matrikkeleneiendomskartteig.teig teig
   WHERE ST_Intersects(o.geom_25833, teig.omrade)
   
                 "
                 )


  dbSendStatement(my_con,
                 "
                 DROP TABLE IF EXISTS hule_eiker_insekt.oak_sel_random_order_backup;
                 ")
  
  dbSendStatement(my_con,
                 "
                CREATE TABLE hule_eiker_insekt.oak_sel_random_order_backup
                AS TABLE hule_eiker_insekt.oak_sel_random_order WITH DATA;
                 ")
```





Test results of filtering out a set of trees
===========
Here we consider only the first 2 trees within each square, plus the single trees that are not isolated. Then we take the first 100 rows (trees).

This can be filtered in QGIS with "tree_order_within_square<=2 OR
(no_trees_within_square<2 AND single_and_lonely IS FALSE)"

```{r}
tree_sel_test <- tree_sel_random_order %>% 
  filter(tree_order_within_square <= 2 |
         (no_trees_within_square <2 & !single_and_lonely))  %>% 
  slice(1:100)
```
```{r, eval = F, echo = FALSE}
tree_sel_test %>% 
    select(RuteID, 
         rute_id_rand_order,
         rute_id_order,
         tree_order_within_square,
         no_trees_within_square)  %>% 
  print(n = Inf)
```


Trestørrelse
-------

```{r}
n_tree_size <- tree_sel_test %>% 
  st_drop_geometry() %>% 
  group_by(large) %>% 
  summarise(no_trees = n()) 

n_tree_size
```

```{r}
n_tree_size_exp <- tree_sel_random_order %>% 
  st_drop_geometry() %>% 
  group_by(large) %>% 
  summarise(no_trees = n()) %>% 
  ungroup() %>% 
  mutate(no_trees_perc = round((no_trees / sum(no_trees) * 100), 2))
  

n_tree_size_exp
```


```{r ford_storlek}
ggplot(n_tree_size, aes(y = no_trees, x = large)) +
  geom_bar(aes(fill = large),
           stat = "identity") +
  geom_point(aes(y = no_trees_perc, x = large),
             data = n_tree_size_exp,
             col = "red") +
  scale_fill_nina(name = "Diam. > 200cm") +
  ylab("Antall tre i utvalget") +
  xlab("Diam. > 200cm")
```

Of these first 100 prioritized trees, we have 35 small trees, and 65 small. Pretty close to double the amount of larger trees. The red dots show the expected number of large and small, if we had choosen them randomly. Good enough?


Isolerte trær
---------
```{r}
n_isolated <- tree_sel_test %>% 
  st_drop_geometry() %>% 
  group_by(no_trees_within_square > 1 ) %>% 
  summarise(no_trees = n()) 

n_isolated

```

```{r}
n_isolated_exp <- tree_sel_random_order %>% 
  st_drop_geometry() %>% 
  group_by(no_trees_within_square > 1 ) %>% 
  summarise(no_trees = n()) %>% 
  ungroup() %>% 
  mutate(no_trees_perc = round((no_trees / sum(no_trees) * 100), 2))
  

n_isolated_exp
```

```{r ford_isolated}
ggplot(n_isolated, aes(y = no_trees, x = `no_trees_within_square > 1`)) +
  geom_bar(aes(fill = `no_trees_within_square > 1`),
           stat = "identity") +
  geom_point(aes(y = no_trees_perc, x = `no_trees_within_square > 1`),
             data = n_isolated_exp,
             col = "red") +
  scale_fill_nina(name = "Isolert tre") +
  ylab("Antall tre i utvalget") +
  xlab("Isolert tre")
```



Verdi-kategorier, fordeling
--------
```{r}
n_verdi <- tree_sel_test %>% 
  st_drop_geometry() %>% 
  group_by(Verdi ) %>% 
  summarise(no_trees = n()) 

n_verdi

```

```{r}
n_verdi_exp <- tree_sel_random_order %>% 
  st_drop_geometry() %>% 
  group_by(Verdi) %>% 
  summarise(no_trees = n()) %>% 
  ungroup() %>% 
  mutate(no_trees_perc = round((no_trees / sum(no_trees) * 100), 2))
  

n_verdi_exp
```

```{r ford_verdi}
ggplot(n_verdi, aes(y = no_trees, x = Verdi)) +
  geom_bar(aes(fill = Verdi),
           stat = "identity") +
  geom_point(aes(y = no_trees_perc, x = Verdi),
             data = n_verdi_exp,
             col = "red") +
  scale_fill_nina(name = "Verdi") +
  ylab("Antall tre i utvalget") +
  xlab("Verdi kat.")
```


Plassering
--------------
```{r}
n_plass <- tree_sel_test %>% 
  st_drop_geometry() %>% 
  group_by(PlasseringAR5) %>% 
  summarise(no_trees = n()) 

n_plass

```

```{r}
n_plass_exp <- tree_sel_random_order %>% 
  st_drop_geometry() %>% 
  group_by(PlasseringAR5) %>% 
  summarise(no_trees = n()) %>% 
  ungroup() %>% 
  mutate(no_trees_perc = round((no_trees / sum(no_trees) * 100), 2))
  

n_plass_exp
```

```{r ford_plass}
ggplot(n_plass, aes(y = no_trees, x = PlasseringAR5)) +
  geom_bar(aes(fill = PlasseringAR5),
           stat = "identity") +
  geom_point(aes(y = no_trees_perc, x = PlasseringAR5),
             data = n_plass_exp,
             col = "red") +
  scale_fill_nina(name = "Plassering") +
  ylab("Antall tre i utvalget") +
  xlab("Plassering")
```


Visible holes
----------

```{r}
n_hole <- tree_sel_test %>% 
  st_drop_geometry() %>% 
  group_by(Synlig_hul) %>% 
  summarise(no_trees = n()) 

n_hole

```

```{r}
n_hole_exp <- tree_sel_random_order %>% 
  st_drop_geometry() %>% 
  group_by(Synlig_hul) %>% 
  summarise(no_trees = n()) %>% 
  ungroup() %>% 
  mutate(no_trees_perc = round((no_trees / sum(no_trees) * 100), 2))
  

n_hole_exp
```

```{r ford_hole}
ggplot(n_hole, aes(y = no_trees, x = Synlig_hul)) +
  geom_bar(aes(fill = Synlig_hul),
           stat = "identity") +
  geom_point(aes(y = no_trees_perc, x = Synlig_hul),
             data = n_hole_exp,
             col = "red") +
  scale_fill_nina(name = "Synlig_hul") +
  ylab("Antall tre i utvalget") +
  xlab("Synlig_hul")
```



Fetch the ssb info for the selection.
======

```{r}

shortlist_ssb_500m <- cand_ssb_500m %>% 
  filter(ssbid %in% tree_sel_test$ssbid)
```

```{r, eval = cache_var}
dbSendStatement(my_con,
                "
      DROP TABLE IF EXISTS hule_eiker_insekt.selection_ssb ; 
      ")


dbSendStatement(my_con,
                "
      CREATE TABLE hule_eiker_insekt.selection_ssb as 
  
      SELECT distinct on(ssbid) s.ssbid, s.geom
      FROM hule_eiker_insekt.oak_sel_random_order o,
      ssb_data_utm33n.ssb_500m s
      WHERE o.ssbid::bigint = s.ssbid;
")


dbSendStatement(my_con,
                "
                ALTER TABLE hule_eiker_insekt.selection_ssb ADD PRIMARY KEY(ssbid);
                ")

dbSendStatement(my_con,
                "
                CREATE INDEX ON  hule_eiker_insekt.selection_ssb USING Gist(geom);
                ")

```




Take a look at the selection

```{r}
#tmap_mode("view")
tm_shape(south) +
  tm_borders() +
tm_shape(shortlist_ssb_500m) +
  tm_borders() +
  tm_shape(tree_sel_test) +
  tm_dots(col = "large",
             size = 0.1,
          palette = ninaPalette())

```



Instruction for QGIS
====================

Project "hule_eiker" at P:\\153018_overvaking_av_insekter_i_hule_eiker\\GIS.

Use the layer oak_sel_random_order.

Some new columns:
'selection_order': Use this order to select trees. This is a random order we can follow.
'rand_selection_order': the original random order (not sorted on RuteID, for documentation)
'rute_id_order': the order the squares appeared in the random sample
'tree_order_within_square': the (random) order of trees within each square. Use tree 1 & 2, but if needed higher numbers if we don't find tree no 1 and 2.
'single_and_lonely': Is the tree alone in its square and is the square > 30 000 km from the nearest square?

I have filtered the entire selection to only look at 2 trees or 1 tree if they are not isolated.

Filter = 
tree_order_within_square<=2 OR
(no_trees_within_square<2 AND single_and_lonely IS FALSE)

If these trees are not enough, we can remove or change the 'tree_order_within_square<=2' to show more trees within each square.

Proposed work within qgis:

1. Sort the table on selection order. Start with tree 1 (selection_order = 1), show the info with the "i" button in QGIS. 
2. Use the matrikkel_no with https://matrikkeldata.nina.no/ to get the owner.
3. Find the contact info for the owner.








